# useId

`useId` generates a stable, unique ID that is consistent between the server and the client. It is designed specifically for accessibility attributes like `id`, `htmlFor`, `aria-labelledby`, and `aria-describedby` — where you need a guaranteed unique identifier that works safely with server-side rendering.

---

## Syntax

```js
const id = useId();
```

- Returns a unique string ID stable across the component's lifetime.
- The same component rendered multiple times generates a different ID for each instance.
- IDs generated by `useId` include the `:` character, which makes them invalid CSS selectors intentionally — they should not be used with `document.querySelector`.

---

## Basic Example

```jsx
import { useId } from "react";

function EmailInput() {
  const id = useId();

  return (
    <div>
      <label htmlFor={id}>Email address</label>
      <input id={id} type="email" placeholder="you@example.com" />
    </div>
  );
}
```

Because `id` is generated by React, it is guaranteed to be unique — even if `EmailInput` appears multiple times on the same page.

---

## Why Not Use a Random ID or Static String

**Static strings** break when a component is rendered more than once — two inputs end up sharing the same `id`, which breaks accessibility and label associations.

```jsx
// Broken — both instances share the same id
function EmailInput() {
  return (
    <>
      <label htmlFor="email">Email</label>
      <input id="email" type="email" />
    </>
  )
}

<EmailInput />
<EmailInput /> // duplicate id="email" — clicking second label focuses first input
```

**Random IDs** (`Math.random()`, `crypto.randomUUID()`) break server-side rendering — the server generates one ID, the client generates a different one, causing a hydration mismatch.

```jsx
// Hydration mismatch — server and client generate different values
const id = Math.random().toString(36).slice(2);
```

`useId` solves both problems.

---

## Multiple IDs from One Call

Rather than calling `useId` multiple times, call it once and construct related IDs from the base ID using a suffix. This keeps the IDs related and reduces the number of hook calls.

```jsx
import { useId } from "react";

function PasswordField() {
  const id = useId();

  return (
    <div>
      <label htmlFor={`${id}-input`}>Password</label>
      <input
        id={`${id}-input`}
        type="password"
        aria-describedby={`${id}-hint`}
      />
      <p id={`${id}-hint`} className="hint">
        Must be at least 8 characters.
      </p>
    </div>
  );
}
```

---

## Accessibility Use Cases

`useId` is especially valuable for ARIA attributes that link elements together.

```jsx
import { useId } from "react";

function Accordion({ title, children }) {
  const id = useId();
  const headingId = `${id}-heading`;
  const panelId = `${id}-panel`;

  return (
    <div>
      <button id={headingId} aria-controls={panelId} aria-expanded="true">
        {title}
      </button>
      <div id={panelId} role="region" aria-labelledby={headingId}>
        {children}
      </div>
    </div>
  );
}
```

```jsx
import { useId } from "react";

function FormField({ label, type = "text", error, hint }) {
  const id = useId();

  return (
    <div className="field">
      <label htmlFor={id}>{label}</label>
      <input
        id={id}
        type={type}
        aria-describedby={hint ? `${id}-hint` : undefined}
        aria-invalid={error ? "true" : undefined}
      />
      {hint && (
        <p id={`${id}-hint`} className="hint">
          {hint}
        </p>
      )}
      {error && (
        <p className="error" role="alert">
          {error}
        </p>
      )}
    </div>
  );
}
```

---

## Multiple Instances Stay Independent

```jsx
function App() {
  return (
    <form>
      <FormField label="First Name" />
      <FormField label="Last Name" />
      <FormField
        label="Email"
        type="email"
        hint="We will never share your email."
      />
    </form>
  );
}
```

Each `FormField` instance gets its own unique `id` — clicking any label correctly targets its associated input.

---

## What useId is Not For

`useId` is purely for accessibility and DOM attribute linking. It is not a general-purpose unique ID generator for other purposes.

Do not use it for:

- Keys in a list — use data IDs from your backend, or a library like `nanoid` for client-generated items.
- Tracking items in state — use a data model ID or an incrementing counter.
- CSS selectors or `querySelector` — the generated ID intentionally contains `:` which is invalid in CSS selectors.

```jsx
// Wrong — useId is not meant for list keys
{
  items.map(() => {
    const id = useId(); // also illegal — hooks cannot be called in loops
    return <li key={id}>...</li>;
  });
}

// Correct — use your data ID
{
  items.map((item) => <li key={item.id}>...</li>);
}
```

---

## Common Mistakes

```jsx
// Calling useId inside a loop or condition — breaks rules of hooks
for (let i = 0; i < count; i++) {
  const id = useId(); // wrong — hooks must be called at the top level
}

// Using for CSS selection
document.querySelector(`#${id}`); // id contains ':' — invalid CSS selector
// Use a ref instead to access DOM elements directly

// Calling useId multiple times for one component unnecessarily
const firstId = useId();
const secondId = useId();
// Better — derive from one base ID
const baseId = useId();
const firstId = `${baseId}-first`;
const secondId = `${baseId}-second`;
```

---

## Summary

`useId` is a small but important hook for writing accessible, SSR-compatible React components. Any time you need to link a `<label>` to an `<input>`, or connect ARIA attributes like `aria-labelledby`, `aria-describedby`, or `aria-controls`, reach for `useId` rather than hardcoded strings or random values. It guarantees uniqueness across instances and consistency between server and client renders.

---

_Next: [useTransition](./UseTransition.md) — mark state updates as non-urgent to keep the UI responsive during heavy re-renders._
